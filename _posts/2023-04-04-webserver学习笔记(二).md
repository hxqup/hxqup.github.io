---
layout:     post
title:      "webserver笔记(二)"
subtitle:   " \"高性能服务器程器程序框架介绍\""
date:       2023-04-04 23:00:00
author:     "Hxq"
header-img: "img/post-bg-2015.jpg"
tags:
    - 网络编程
---

> 游双在《Linux高性能服务器编程》中，把服务器解构成三个主要模块：
>
> * I/O处理单元。
> * 逻辑单元。
> * 存储单元

## 服务器模型

### C/S模型

C/S模型在服务器启动后，首先创建一个或多个监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。服务器稳定运行后，客户端可以调用connect函数向服务器发起连接。

**由于客户连接请求是随机到达的异步事件**，服务器需要使用某种I/O模型来监听这一事件。当监听到连接请求后，服务器调用accept函数接受它，并分配一个逻辑单元为新的连接服务。客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以主动断开连接。

C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显，服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的相应。

### P2P模型

P2P模型使得每台机器在消耗服务的同时也在提供服务，这样资源能充分、自由地共享，云计算机群可以看作P2P模型的典范。但P2P模型在用户之间传输请求过多时，网络负载将加重。

## 服务器编程框架

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/6OkibcrXVmBH2ZO50WrURwTiaNKTH7tCia3QENT2MZibwxf74GnEpuxqz30UHUJZuJ9d0vYP8SzkU5fK1sMw4DNzng/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

主要由I/O单元，逻辑单元和网络存储单元组成，各个单元之间通过请求队列进行通信。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要某种机制来处理竞态条件。请求队列通常被实现为池的一部分。

## I/O模型

* **阻塞I/O**:针对阻塞I/O的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。
* **非阻塞I/O**:针对非阻塞I/O的系统调用总是立即返回，而不管此事件是否已经发生。如果事件没有立即发生，返回-1，此时我们要根据errno区分两种情况。对accept、send和recv而言，事件未发生时errno为EAGAIN或者EWOULDBLOCK。对connect而言，errno被设置成EINPROGRESS。**非阻塞I/O通常和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号**。
* **信号驱动I/O**:我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获SIGIO信号，这样当目标文件描述符上有事件触发时，SIGIO信号的信号处理函数被触发，我们可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作。
* **I/O复用**：应用程序通过I/O复用向内核注册一组事件，内核通过I/O复用函数把其中的就绪事件通知给应用程序。I/O复用函数本身是阻塞的，我们能提高效率的原因在于它们能同时监听多个I/O事件的能力。
* **异步I/O**:异步I/O真正的读写操作由内核接管，**同步I/O向应用通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件**

## 事件处理模式

* reactor模式：主线程只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程，读写数据、接收新连接均在工作线程完成，通常由**同步I/O**实现。
* proactor模式：主线程和内核负责处理读写数据、接收新连接等I/O操作，工作线程仅负责业务逻辑，通常由异步I/O实现。
* 模拟proactor模式：由于异步I/O并不成熟，实际中使用较少，可以使用同步I/O的方式模拟Proactor模式。其原理是：主线程完成数据读写操作，读写完成后，主线程向工作线程通知这一完成事件，接下来工作线程对读写结果进行逻辑处理。

## 并发模式

<--!

从实现上来说，并发编程主要有多进程与多线程两种方式。

\--!>

并发模式指I/O处理单元与多个逻辑单元之间协调完成任务的方法。

> 并发模式中的同步与异步
>
> * 同步指程序完全按照代码序列的顺序执行
> * 异步指程序的执行需要由系统事件驱动

1. 半同步/半异步模式：同步线程用于处理客户逻辑，异步线程用于处理I/O事件。异步线程监听到客户请求后，将其封装成请求对象并插入请求队列，请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程取决于线程池的实现。

2. 半同步/半反应堆模式：异步线程只有一个，由主线程充当，其采用事件模式可以为Reactor，也可以是模拟Proactor。

​	半同步/半反应堆模式存在以下缺点：

* 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都要对其加锁保护。
* 每个工作线程在同一事件只能处理一个客户请求。如果通过增加工作线程来解决这一问题，则工作线程的切换也会耗费大量CPU时间。

3. 从而引出了更高效的半同步/半反应堆模式：one loop per thread模式。在这种模式下，主线程只负责监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程接收之并将返回的连接socket派发给工作线程。此后，该线程上任何I/O操作都由被选中的工作线程处理，直到客户关闭连接。在这种情况下，每个线程都维持自己的时间循环，它们独立地监听不同事件。
4. 领导者/追随者模式：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序中仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，等待成为领导者，如果当前领导者检测到I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。